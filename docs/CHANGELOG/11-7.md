### 一个想法

如果只是针对格式化的话，实际上用类似红绿树的结构会更加好

```rust
enum Element {
    Token(TokenData),
    Node(NodeData),
}

struct TokenData {
    kind: SyntaxKind,
    text: String,
}

struct NodeData {
    kind: SyntaxKind,
    children: Vec<Element>
}
```

因为这样的话可以很方便的对节点进行操作

- 添加空格：遍历 `children` 到指定位置，后面插入一个 `Whitesapce Token`
- 新建一行：添加一个 `NewLine Token`
- 双引号改为单引号：找到 `StringLiteral Token`，改他的 `text`
- 句尾分号：每个 `Statement Node` 的 `children` 最后插入一个 `Semi Token`

不过根据目前已有架构，要得到这个结构只能基于目前的 `enum Node` 的 AST 进行遍历转换

存在代价，并且很蠢，因为原本是可以直接生成的

### 另一个想法

访问者的遍历行为统一控制，提供 `beforeVisit` 和 `afterVisit` 等 hooks 给 `rules` 进行使用

可是说到底目前就还没有明确 `rules` 到底该长什么样....